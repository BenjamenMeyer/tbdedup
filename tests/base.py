"""
Copyright 2023 Benjamen R. Meyer

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""
import datetime
import os
import random
import tempfile
import unittest

from tbdedup.mbox import mboxfile


class TestCase(unittest.TestCase):
    """
    Custom Test Case support for standard (non-AsyncIO) tests
    """

    def setUp(self):
        super(TestCase, self).setUp()

    def tearDown(self):
        super(TestCase, self).tearDown()


class AsyncioTestCase(unittest.IsolatedAsyncioTestCase):
    """
    Custom Test Case support for tests using AsyncIO functionality
    """

    def setUp(self):
        super(unittest.IsolatedAsyncioTestCase, self).setUp()

    async def asyncSetUp(self):
        pass

    def tearDown(self):
        super(unittest.IsolatedAsyncioTestCase, self).tearDown()

    async def asyncTearDown(self):
        pass


class ValueSwap(object):
    """
    Temporarily swap a value on a module

    .. note:: this is not async safe

    :param module: Python module or object to be modified
    :param value_to_replace: name of the attribute on the module to update
    :param new_value: value to temporarily set the attribute to
    """

    def __init__(self, module, value_to_replace, new_value):
        self.module = module
        self.value_to_replace = value_to_replace
        self.new_value = new_value
        self.old_value = getattr(self.module, self.value_to_replace)

    def __enter__(self):
        setattr(self.module, self.value_to_replace, self.new_value)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        setattr(self.module, self.value_to_replace, self.old_value)


class GenericOptions(object):
    """
    Options object that mimics the object generated by argparse
    Any KV pair in the parameters becomes an attribute on the
    object.
    """

    def __init__(self, **kv):
        for k, v in kv.items():
            setattr(self, k, v)


class KeepLocalDirClean(object):
    """
    use a temporary directory as the current working directory
    so that tests do not drop files into the code directories
    and become hard to cleanup
    """

    def __init__(self):
        self.cwd = os.getcwd()
        self.temp_dir = tempfile.TemporaryDirectory()

    def __enter__(self):
        os.chdir(self.temp_dir.name)
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        os.chdir(self.cwd)


def generate_mbox_filename(expected_format, use_content_boundary):
    """
    Generate MBOX Filename based on the desired format

    :param expected_format: MBOX being generated; encoded to the filename
    :param use_content_boundary: whether or not the email data
        will be generated using content boundaries; encoded to the filename
    :return: string containing the base filename; caller needs to add
        path data for a fully qualified file name

    .. note:: if expected_format is unknown then a `u` is used. Otherwise
        the standard abbreviations are used (`MBOXO` -> `o`, `MBOXRD` -> `rd`,
        `MBOXCL` -> `cl`, `MBOXCL2` -> `cl2`)
    """
    generated_name = "mbox_format_mbox"
    if expected_format == mboxfile.Mailbox.MBOXO:
        generated_name = generated_name + "o"
    elif expected_format == mboxfile.Mailbox.MBOXRD:
        generated_name = generated_name + "rd"
    elif expected_format == mboxfile.Mailbox.MBOXCL:
        generated_name = generated_name + "cl"
    elif expected_format == mboxfile.Mailbox.MBOXCL2:
        generated_name = generated_name + "cl2"
    else:
        # unknown format
        generated_name = generated_name + "u"

    if use_content_boundary:
        generated_name = generated_name + "_content_boundary"

    return generated_name


class EmailGenerator(object):
    """
    Generate email data
    """

    DAY_OF_WEEK = {
        0: "Mon",
        1: "Tue",
        2: "Wed",
        3: "Thu",
        4: "Fri",
        5: "Sat",
        6: "Sun",

    }

    MONTH_OF_YEAR = {
        1: "Jan",
        2: "Feb",
        3: "Mar",
        4: "Apr",
        5: "May",
        6: "Jun",
        7: "Jul",
        8: "Aug",
        9: "Sep",
        10: "Oct",
        11: "Nov",
        12: "Dec",
    }

    @classmethod
    def dayOfWeek(cls, dt):
        """
        Get the 3 letter day of the week for the specified datetime value

        :param dt: datetime value to use
        :return: 3 character string for the associated day of the week
        """
        return cls.DAY_OF_WEEK[dt.weekday()]

    @classmethod
    def monthOfYear(cls, dt):
        """
        Get the 3 letter month of the year for the specified datetime value

        :param dt: datetime value to use
        :return: 3 character string for the associated month
        """
        return cls.MONTH_OF_YEAR[dt.month]

    @classmethod
    def generate_date(cls, dt):
        """
        Generate a date value for the MBOX FROM Line
        using the following specification:

            [DOW] [MOY] [DD] [hh]:[mm]:[ss] [yyyy]

        DOW = 3 letter Day of the Week
        MOY = 3 letter Month of the Year
        DD = 2 digit day of the month
        hh = 2 digit hour of the day
        mm = 2 digit minute of the hour
        ss = 2 digit second of the minute
        yyyy = 4 digit year

        :param dt: datetime value to use
        :return: string containing the formatted data

        .. note:: recommend using datetime.datetime.utcnow() for `dt`
        """
        dow = cls.dayOfWeek(dt)
        moy = cls.monthOfYear(dt)
        day = dt.day
        hour = dt.hour
        minute = dt.minute
        second = dt.second
        year = dt.year
        # [DOW] [MOY] [DD] [hh]:[mm]:[ss] [yyyy]
        return f"{dow} {moy} {day:02} {hour:02}:{minute:02}:{second:02} {year:04}"

    @classmethod
    def write_email(cls, file, from_line, headers, body, is_first):
        """
        Write the email data to the file objection

        :param file: file object to be written to
        :param from_line: MBOX FROM Line Separator
        :param headers: the email headers to be written
        :param body: the email body as a string to be written
        :param is_first: boolean of whether this is the first email
            in the file; if so, the file should be at the start of
            the file (ftell() == 0)
        :return: None
        """
        if not is_first:
            print("", file=file)

        print(from_line, file=file)
        for k, v in headers.items():
            print(f"{k}: {v}", file=file)
        print("", file=file)
        print(body, file=file)

    @classmethod
    def email_to_string(cls, from_line, headers, body):
        """
        Write the email data into a string

        :param file: file object to be written to
        :param from_line: MBOX FROM Line Separator
        :param headers: the email headers to be written
        :param body: the email body as a string to be written
        :return: string containing the email data
        """
        email_string_data = [
            from_line,
        ]
        for k, v in headers.items():
            email_string_data.append(f"{k}: {v}")
        email_string_data.append("")
        body_data = body.split('\n')
        email_string_data.extend(body_data)
        return '\n'.join(email_string_data)

    @classmethod
    def get_email_address(
        cls,
        min_account=3, max_account=40,
        min_server=10, max_server=40,
        min_tld=3, max_tld=10
    ):
        """
        generate an email address per the parameters

        :param min_account: minimum length of the account name
        :param max_account: maximum length of the account name
        :param min_server: minimum length of the server name
        :param max_server: maximum length of the server name
        :param min_tld: minimum length of the tld name
        :param max_tld: maximum length of the tld name
        :returns: string containing the generated email address
        """
        valid_account_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890"
        valid_domain_chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
        account = ''
        server = ''
        tld = ''
        for _ in range(random.randrange(min_account, max_account)):
            account = account + random.choice(valid_account_chars)
        for _ in range(random.randrange(min_server, max_server)):
            server = server + random.choice(valid_domain_chars)
        for _ in range(random.randrange(min_tld, max_tld)):
            tld = tld + random.choice(valid_domain_chars)
        return f"{account}@{server}.{tld}"

    @classmethod
    def generate_email(cls, index, store_content_length, use_content_boundaries):
        """
        Generate an email matching the specifications

        :param index: index of the email generated, namely used for the boundary
            data to help differentiate it and the Message-ID header
        :param store_content_length: whether or not to set the Content Length
            header field
        :param use_content_boundaries: whether or not to generate the email
            body using content boundaries; or to generate a simple plain text
            email body.

        :return: tuple (dictionary email headers, string of the email body)
        """
        from_email = cls.get_email_address()
        email_headers = {
            'From': from_email,
            'To': cls.get_email_address(),
            'Subject': f"Sent {index:030}",
            'Date': datetime.datetime.utcnow().isoformat(),
            'Reply-To': from_email,
            'Message-ID': f"{index:030}",
        }
        email_body = f"Test message number {index:030}"
        email_boundary = None
        if use_content_boundaries:
            email_boundary = f"=========boundary-{index:040}===="
            email_boundary_alternate = "-------boundary-{index:010}----"
            email_headers['Content-Type'] = f"multipart/mixed; boundary=\"{email_boundary}\""
            bounded_email = '\n'.join(
                [
                    f"--{email_boundary}",
                    "Content-Type: multipart/altnative;",
                    f"    boundary=\"{email_boundary_alternate}\"",
                    "",
                    f"--{email_boundary_alternate}",
                    "Content-Type: text/plain; charset=us-ascii",
                    "",
                    email_body,
                    f"--{email_boundary_alternate}",
                    "Content-Type: text/html; charset=us-ascii",
                    "",
                    f"<html><body><div>{email_body}</div></body></html>"
                    f"--{email_boundary_alternate}",
                    f"--{email_boundary}",
                ],
            )

        if store_content_length:
            email_headers['Content-Length'] = len(email_body) + 1

        return (
            email_headers,
            email_body,
            f"--{email_boundary}"
            if email_boundary is not None
            else email_boundary   # None
        )

    @classmethod
    def GenerateMboxFile(cls, filename, email_count, from_line_format, has_content_length, use_boundary_markers):
        """
        Generates MBOX file data to make valid MBOX files for testing purposes.

        :param from_line_format: format to use for the FROM line; caller should pass
            in `"FROM"` or `> FROM`. The method will add the timestamp
        :param has_content_length: boolean value for whether or not to generate
            a `Content-Length` header should be included in the email header data

        MBOX files contain copies of Emails. Each entry is denoted by a blank line
        followed by a `FROM -` line, with the exception of the very first record which
        lacks the preceding blank line and just starts with the `FROM -` line. The
        `FROM -` line is differentiated from the `FROM` header field as the header
        fields are semi-colon separated key-value entries.

        There are 4 types of MBOX files:

            MBOXO
                MBOX FROM Format: "FROM - <timestamp>>"
                Content Length header is missing

            MBOXRD
                MBOX FROM Format: "><optional whitespace>FROM - <timestamp>"
                Content Length header is missing

            MBOXCL
                MBOX FROM Format: "><optional whitespace>FROM - <timestamp>"
                Content Length header set

            MBOXCL2
                MBOX FROM Format: "FROM - <timestamp>"
                Content Length header set

        .. note:: The MBOXRD and MBOXCL formats do not validate using the mfck tool
            due the FROM line formatting. however, MBOXO and MBOXCL2 do validate
            just fine. MBOXRD and MBOXCL are against the current code spec which may
            be incorrect - it might be the FROM line being detected is the same
            and the difference is in the header/body data only.
        """
        with open(filename, "wt") as mbox_writer:
            for email_index in range(email_count):
                eh, eb, _ = cls.generate_email(
                    email_index,
                    has_content_length,
                    use_boundary_markers,
                )
                dt = datetime.datetime.utcnow()
                cls.write_email(
                    mbox_writer,
                    f"{from_line_format} - {cls.generate_date(dt)}",
                    eh,
                    eb,
                    0 == email_index,
                )
